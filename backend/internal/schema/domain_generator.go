package schema

import (
	"context"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"insightiq/backend/internal/embedding"
	"insightiq/backend/internal/vectorstore"
)

// DomainGeneratorService generates dynamic domain contexts from analyzed schemas
type DomainGeneratorService struct {
	analyzerService  *AnalyzerService
	vectorStore      vectorstore.VectorStore
	embeddingService embedding.EmbeddingService
	logger           *slog.Logger
}

// NewDomainGeneratorService creates a new dynamic domain generator
func NewDomainGeneratorService(
	analyzerService *AnalyzerService,
	vectorStore vectorstore.VectorStore,
	embeddingService embedding.EmbeddingService,
	logger *slog.Logger,
) *DomainGeneratorService {
	return &DomainGeneratorService{
		analyzerService:  analyzerService,
		vectorStore:      vectorStore,
		embeddingService: embeddingService,
		logger:           logger,
	}
}

// GenerateAndIngestDomainContexts performs end-to-end domain context generation and ingestion
func (d *DomainGeneratorService) GenerateAndIngestDomainContexts(ctx context.Context, connectorID string) error {
	d.logger.Info("Starting dynamic domain context generation", "connector_id", connectorID)

	// Step 1: Analyze business context from schema
	schemaContext, err := d.analyzerService.AnalyzeBusinessContext(ctx, connectorID)
	if err != nil {
		return fmt.Errorf("failed to analyze business context: %w", err)
	}

	// Step 2: Create vector collection for this connector's domains
	collectionName := fmt.Sprintf("domains_%s", connectorID)
	dimension := d.embeddingService.GetDimension()

	if err := d.vectorStore.CreateCollection(ctx, collectionName, dimension); err != nil {
		d.logger.Warn("Failed to create domain collection (may already exist)", "error", err, "collection", collectionName)
	}

	// Step 3: Generate embeddings and ingest domain contexts
	for _, domainCtx := range schemaContext.DetectedDomains {
		if err := d.ingestDomainContext(ctx, collectionName, domainCtx, schemaContext.ConnectorID); err != nil {
			d.logger.Error("Failed to ingest domain context",
				"domain", domainCtx.Domain,
				"connector_id", connectorID,
				"error", err)
			continue
		}
		d.logger.Info("Successfully ingested dynamic domain context",
			"domain", domainCtx.Domain,
			"connector_id", connectorID,
			"confidence", domainCtx.Confidence)
	}

	// Step 4: Update global domain contexts collection
	if err := d.updateGlobalDomainContexts(ctx, schemaContext.DetectedDomains, connectorID); err != nil {
		d.logger.Warn("Failed to update global domain contexts", "error", err)
	}

	d.logger.Info("Dynamic domain context generation completed",
		"connector_id", connectorID,
		"primary_domain", schemaContext.PrimaryDomain,
		"detected_domains", len(schemaContext.DetectedDomains))

	return nil
}

// ingestDomainContext ingests a single dynamic domain context into vector store
func (d *DomainGeneratorService) ingestDomainContext(ctx context.Context, collectionName string, domainCtx DomainContext, connectorID string) error {
	// Create comprehensive searchable text for the domain
	searchText := d.createDomainSearchText(domainCtx)

	// Generate embedding for the domain context
	embeddingResp, err := d.embeddingService.GenerateEmbedding(ctx, searchText)
	if err != nil {
		return fmt.Errorf("failed to generate embedding for domain %s: %w", domainCtx.Domain, err)
	}

	// Create enhanced metadata with schema information
	metadata := map[string]interface{}{
		"type":           "dynamic_domain_context",
		"domain":         string(domainCtx.Domain),
		"connector_id":   connectorID,
		"description":    domainCtx.Description,
		"keywords":       domainCtx.Keywords,
		"metrics":        domainCtx.Metrics,
		"dimensions":     domainCtx.Dimensions,
		"table_count":    len(domainCtx.Tables),
		"confidence":     domainCtx.Confidence,
		"auto_generated": domainCtx.AutoGenerated,
		"updated_at":     domainCtx.LastUpdated.Format(time.RFC3339),
	}

	// Add table-specific metadata
	var tableNames []string
	var businessTags []string
	for _, table := range domainCtx.Tables {
		tableNames = append(tableNames, table.TableName)
		businessTags = append(businessTags, table.BusinessTags...)
	}
	metadata["table_names"] = tableNames
	metadata["business_tags"] = businessTags

	// Add pattern information
	var patternDescriptions []string
	for _, pattern := range domainCtx.Patterns {
		patternDescriptions = append(patternDescriptions, pattern.Description)
	}
	metadata["pattern_descriptions"] = patternDescriptions

	// Create vector with enhanced metadata
	vector := vectorstore.Vector{
		ID:       fmt.Sprintf("dynamic_domain_%s_%s", connectorID, domainCtx.Domain),
		Values:   embeddingResp.Embedding,
		Metadata: metadata,
	}

	// Upsert the vector
	return d.vectorStore.UpsertVector(ctx, collectionName, vector)
}

// updateGlobalDomainContexts updates the global domain contexts collection
func (d *DomainGeneratorService) updateGlobalDomainContexts(ctx context.Context, domainContexts []DomainContext, connectorID string) error {
	globalCollection := "domain_contexts"

	for _, domainCtx := range domainContexts {
		// Create searchable text
		searchText := d.createDomainSearchText(domainCtx)

		// Generate embedding
		embeddingResp, err := d.embeddingService.GenerateEmbedding(ctx, searchText)
		if err != nil {
			d.logger.Warn("Failed to generate embedding for global domain context",
				"domain", domainCtx.Domain, "error", err)
			continue
		}

		// Create global metadata (less specific than connector-specific)
		globalMetadata := map[string]interface{}{
			"type":           "domain_context",
			"domain":         string(domainCtx.Domain),
			"source":         "dynamic_generation",
			"connector_id":   connectorID,
			"description":    domainCtx.Description,
			"keywords":       domainCtx.Keywords[:min(10, len(domainCtx.Keywords))], // Limit for performance
			"confidence":     domainCtx.Confidence,
			"auto_generated": true,
			"updated_at":     time.Now().Format(time.RFC3339),
		}

		// Create vector for global collection
		globalVector := vectorstore.Vector{
			ID:       fmt.Sprintf("domain_%s_%s", domainCtx.Domain, connectorID),
			Values:   embeddingResp.Embedding,
			Metadata: globalMetadata,
		}

		// Upsert to global collection
		if err := d.vectorStore.UpsertVector(ctx, globalCollection, globalVector); err != nil {
			d.logger.Warn("Failed to update global domain context",
				"domain", domainCtx.Domain, "error", err)
		}
	}

	return nil
}

// createDomainSearchText creates a comprehensive searchable representation of a domain
func (d *DomainGeneratorService) createDomainSearchText(domainCtx DomainContext) string {
	var textParts []string

	// Add domain name and description
	textParts = append(textParts, string(domainCtx.Domain))
	textParts = append(textParts, domainCtx.Description)

	// Add keywords
	textParts = append(textParts, domainCtx.Keywords...)

	// Add metrics and dimensions
	textParts = append(textParts, domainCtx.Metrics...)
	textParts = append(textParts, domainCtx.Dimensions...)

	// Add table information
	for _, table := range domainCtx.Tables {
		textParts = append(textParts, table.TableName)
		textParts = append(textParts, table.Description)
		textParts = append(textParts, table.BusinessTags...)

		// Add important column names
		for _, col := range table.Columns {
			if col.IsMetric || col.IsDimension || col.IsID {
				textParts = append(textParts, col.Name)
				if col.Description != "" {
					textParts = append(textParts, col.Description)
				}
			}
		}
	}

	// Add glossary terms
	for _, glossary := range domainCtx.Glossary {
		textParts = append(textParts, glossary.Term)
		textParts = append(textParts, glossary.Definition)
		textParts = append(textParts, glossary.Synonyms...)
	}

	// Add query patterns
	for _, pattern := range domainCtx.Patterns {
		textParts = append(textParts, pattern.Description)
		textParts = append(textParts, pattern.Keywords...)
		textParts = append(textParts, pattern.Examples...)
	}

	// Join all parts with spaces
	return strings.Join(textParts, " ")
}

// GetConnectorDomains retrieves all domain contexts for a specific connector
func (d *DomainGeneratorService) GetConnectorDomains(ctx context.Context, connectorID string) ([]DomainContext, error) {
	collectionName := fmt.Sprintf("domains_%s", connectorID)

	// Search for all vectors in the connector's collection
	queryVector := make([]float64, d.embeddingService.GetDimension())
	searchResults, err := d.vectorStore.SearchVectors(ctx, collectionName, queryVector, 50)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve connector domains: %w", err)
	}

	// Convert search results back to domain contexts
	var domains []DomainContext
	for _, result := range searchResults {
		domain := d.vectorResultToDomainContext(result)
		if domain != nil {
			domains = append(domains, *domain)
		}
	}

	d.logger.Info("Retrieved connector domains",
		"connector_id", connectorID,
		"domain_count", len(domains))

	return domains, nil
}

// vectorResultToDomainContext converts a vector search result back to a domain context
func (d *DomainGeneratorService) vectorResultToDomainContext(result vectorstore.SearchResult) *DomainContext {
	metadata := result.Vector.Metadata

	// Extract domain information from metadata
	domain, ok := metadata["domain"].(string)
	if !ok {
		return nil
	}

	description, _ := metadata["description"].(string)
	confidence, _ := metadata["confidence"].(float64)
	autoGenerated, _ := metadata["auto_generated"].(bool)

	// Extract string slices with type checking
	keywords := d.extractStringSlice(metadata["keywords"])
	metrics := d.extractStringSlice(metadata["metrics"])
	dimensions := d.extractStringSlice(metadata["dimensions"])

	// Parse timestamp
	var lastUpdated time.Time
	if updatedStr, ok := metadata["updated_at"].(string); ok {
		lastUpdated, _ = time.Parse(time.RFC3339, updatedStr)
	}

	return &DomainContext{
		Domain:        Domain(domain),
		Description:   description,
		Keywords:      keywords,
		Metrics:       metrics,
		Dimensions:    dimensions,
		Confidence:    confidence,
		AutoGenerated: autoGenerated,
		LastUpdated:   lastUpdated,
		// Note: Tables, Glossary, and Patterns would need separate storage/retrieval
		// for full reconstruction, but basic context is sufficient for most use cases
	}
}

// extractStringSlice safely extracts a string slice from metadata
func (d *DomainGeneratorService) extractStringSlice(value interface{}) []string {
	if value == nil {
		return []string{}
	}

	switch v := value.(type) {
	case []string:
		return v
	case []interface{}:
		var result []string
		for _, item := range v {
			if str, ok := item.(string); ok {
				result = append(result, str)
			}
		}
		return result
	default:
		return []string{}
	}
}

// RefreshDomainContexts regenerates domain contexts for a connector
func (d *DomainGeneratorService) RefreshDomainContexts(ctx context.Context, connectorID string) error {
	d.logger.Info("Refreshing domain contexts", "connector_id", connectorID)

	// Delete existing contexts for this connector
	collectionName := fmt.Sprintf("domains_%s", connectorID)
	if err := d.vectorStore.DeleteCollection(ctx, collectionName); err != nil {
		d.logger.Warn("Failed to delete existing collection", "collection", collectionName, "error", err)
	}

	// Regenerate contexts
	return d.GenerateAndIngestDomainContexts(ctx, connectorID)
}

// ListConnectorCollections returns all connector-specific domain collections
func (d *DomainGeneratorService) ListConnectorCollections(ctx context.Context) ([]string, error) {
	allCollections, err := d.vectorStore.ListCollections(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list collections: %w", err)
	}

	var connectorCollections []string
	for _, collection := range allCollections {
		if strings.HasPrefix(collection, "domains_") {
			connectorCollections = append(connectorCollections, collection)
		}
	}

	return connectorCollections, nil
}